[{"categories":null,"contents":" Table of Contents 1 Why the our approach is preferable 1.1 svg preview images vs Mathjax 1.2 svg preview images vs Tikzjax 2 The basic idea of our approach 2.1 Using org-mode and LaTeX to generate svg preview images 2.2 Using ox-hugo and hugo to embed the images into html 2.3 Using css to change alignment and styling 2.4 Optional: Using org-mode to create hyperlinks to the images 3 Getting dvisvgm to work 4 Getting the colors right 5 Linking equations with target links: 6 6.1 1 Alles, WAS in dollar signs gewarppt ist - egal ob inline oder nicht. kriegt diese syntax: 6.2 2 1 Why the our approach is preferable # 1.1 svg preview images vs Mathjax # Before we get into how we\u0026rsquo;re doing things, let us first get an idea of why it is preferable to do so. This is an important question since there are other (and less complicated) ways to get LaTeX formulas typeset in html. Speficially, there is Mathjax \u0026ndash; a javascript application which allows typesetting LaTeX formulas in html. Now don\u0026rsquo;t get me wrong, Mathjax is a great tool, but it has severe limitations.\nIn comparison to the approach we are choosing, Mathjax is much less flexible. Specifically, there are just a few LaTeX packages out there that you can actually use with Mathjax. This was the most important reason for me to switch to svg images: I was not able to typeset my formulas upright. In philosophical logic, it is common practice to write actual formulas upright, whilst preserving italicization for scheme letters. To do that correctly, you will need the package unicode-math with the package option math-style=upright, but this simply does not work with Mathjax. And even if this had not been a problem, there were still some metalogical signs missing. For example, the shadow brackets and turned iota $\\,$.\nThings are getting even worse if you want to typeset very specific formulas. The most obvious case for me was trying to get the formulas of Frege\u0026rsquo;s Begriffsschrift working. This is simply not possible in Mathjax, whilst with our approach, we can write things like\nwhich would not be possible with Mathjax. We can now even use a tabular environment to group these formulas:\n","date":"10 Apr. 2022","lastmod":"10 Apr. 2022","permalink":"https://Perangelot.github.io/posts/an-in-depth-guide-to-writing-full-fledged-latex-in-html-using-ox-hugo-vom-10.04.2022/","tags":["blog-post"],"title":"An in-depth guide to writing full-fledged LaTeX in html using ox-hugo"},{"categories":null,"contents":" 1 1 1 (org-create-formula-image(\u0026quot;\\\\begin{hi}\\n\\\\end{hi}\\n\u0026quot; \u0026ldquo;media/storage/sciebo privat/org-mode\u0026rdquo; (:foreground default :background default :scale 1.0 :html-foreground \u0026ldquo;#AAA7B3\u0026rdquo; :html-background nil :html-scale 1.0 :matchers (\u0026ldquo;begin\u0026rdquo; \u0026ldquo;\u0026rdquo; \u0026ldquo;$$\u0026rdquo; \u0026ldquo;\\\\(\u0026rdquo; \u0026ldquo;\\\\[\u0026rdquo;)) nil dvisvgm))\n","date":"08 Apr. 2022","lastmod":"08 Apr. 2022","permalink":"https://Perangelot.github.io/posts/try/","tags":["logical"],"title":""},{"categories":null,"contents":"","date":"08 Apr. 2022","lastmod":"08 Apr. 2022","permalink":"https://Perangelot.github.io/posts/an-introduction-to-freges-notation-vom-08.04.2022/","tags":["frege","logic","historical"],"title":"An Introduction to Frege's Notation"},{"categories":null,"contents":" 1 The interdefinability of connectives # As a first approximation, let us get familiar with one very simple idea: Some logical constants can be understood as abbreviations of others. For example, you can introduce the material conditional by stipulating that\nIn our example, we used two connectives, and , to define another one \u0026ndash; . Note that this is a strict syntactical definition in the following sense: Nothing is claimed about the meaning of or . Instead, something is claimed about the arrangement of (sequences of) symbols, namely that the sequence of a well-formed-formula followed by an arrow-sign and another well-formed formula in this order may always replace the sequence of a hook-sign, a left parenthesis, a well-formed-formula, a hat-sign, a hook-sign and a well-formed formula in that order.\nNonetheless, we of course have a semantic interpretation in mind: We want the definiens to yield the same truth-values of the ones usually attributed to the definiendum. In short: should have the same truth-conditions as the ones would have if it was not introduced as an abbreviation. That this is the case for our definition can easily be shown by constructing a truth-table:\nAs we can see, the truth-conditions for are the same as those has in a classical system of logic. Thus, we do not need to introduce a new symbol to our alphabet and define its truth-conditions; it suffices to read as \u0026ldquo;If A, then B\u0026rdquo;.\nFollowing the same procedure, we can also define and in terms of and : With a natural language interpretation, we can interpret (2) as stipulating that \u0026ldquo;or\u0026rdquo; abbreviates \u0026ldquo;not both are false\u0026rdquo; and (3) as stipulating that \u0026ldquo;if and only if\u0026rdquo; abbreviates \u0026ldquo;not just one is true or false\u0026rdquo;. If we wanted to, we could also define the strong alternation like this:\nAs it happens, we have now used two connectives \u0026ndash; and \u0026ndash; to show that all other connectives can be introduced as abbreviations of them, in the sense that the definitions yield the same truth-values as the connectives if they were introduced as primitive symbols.\nThis is not self-evident, since some pairs of connectives are not capable of defining all others; for example and cannot because there is no way to get to , or .\n2 The interdefinability of quantifiers # Now we know that under certain conditions, we only need a smaller set of connectives to define the whole set of connectives. While this suffices for propositional logic, there are two more logical symbols1 in predicate logic we need to take into consideration: and . Here, we can also define one quantifier in terms of the other using . For example, we can stipulate that\nand thereby define the existential quantifier by means of and . To see this is working as intended, we simply need our definition and the rule of Double Negation (both introduction and eliminiation)2:\nOne could, of course, also take as primitive and define in terms of it. Similarly, you can define a weak modal operator like by the corresponding strong one \u0026ndash; in this case \u0026ndash; and vice versa.\n3 A definition of functional completeness # In the last two sections, we have shown that we only need some connectives and quantifiers in our syntax to express all of them. We also made plausible that not every set of logical constants is capable of doing this, so we are talking about an interesting property here \u0026ndash; a property usually called functional completeness or expressive completeness. Now we have an idea of what it is, so let us consider a formal definition. As it happens, there are several definitions of this concept, but they only deviate in minor points. I suggest the following definition, which is based on Yaqub, 2015, p. 110:\nThe basic idea of this definition is that if you have some connectives \u0026ndash; represented by the set , you have all connectives. With the notion of functional completeness in place, we are now able to express what we discovered in sections 1 and 2 very briefly:\nNote that these are far from all sets of connectives that are functionally complete for propositional or predicate logic. For example, is functionally complete, too, as well as .\n4 The Sheffer stroke and Peirce\u0026rsquo;s arrow # Incidentally, you can even get all connectives defined by a single sign, the Sheffer stroke . Its semantics are defined like this:\nThe Sheffer stroke can be read as \u0026ldquo;neither A nor B\u0026rdquo;. As a limiting case, then, imagine that A and B are the same proposition. Then we can stipulate:\nThis also makes sense from a natural-language standpoint: \u0026ldquo;neither A nor A\u0026rdquo; is just a peculiar way of saying \u0026ldquo;not A\u0026rdquo;. The rest of the connectives is now easily defined on the basis of and .\nSimilarly, we can define all connectives as abbreviations of Peirce\u0026rsquo;s Arrow, whose truth-conditions are defined this way:\nIn a similar, fashion, Peirce\u0026rsquo;s arrow can be read as \u0026ldquo;not both A and B\u0026rdquo;. This allows the following definition:\n\u0026ldquo;Not both A and A\u0026rdquo;, again, simply means the same as \u0026ldquo;not A\u0026rdquo;. As a side note for computer scientists: The Sheffer stroke corresponds to the NAND operator, Peirce\u0026rsquo;s arrow to the NOR operator. Peirce\u0026rsquo;s arrow is sometimes also called \u0026ldquo;Quine\u0026rsquo;s dagger\u0026rdquo;.\n5 The use of functional completeness # Now that we know what functional completeness is, the question arises why it would matter to talk about it. After all, no matter whether you introduce all connectives as primitive symbols or some of them as abbreviations, all formulas have the same truth-values and proof theory stays the same anyway.\nWhat seems to be a reason against introducing small functionally complete sets of operators in the first place turns out to be just the reason for doing so. On the one hand, thinking about it makes clear which relations the connectives hold to each other, which is a value in itself. It also helps compare different logics. For example, in intuitionistic logic, the quantifiers are not interdefinable, and in three-valued logic, the sets of functionally complete connectives are much more limited.\nOn the other hand, and most importantly, if you intend to prove something not in, but about a logical language, you will most often find yourself in a situation which requires you to use proof by induction on the complexity of formulae3. This, in effect, means, that you need to show for all possible combinations of well-formed formulae that the proposition you claim holds. By making use of functionally complete sets, you can reduce the number of those possible combinations, which makes the proofs much smaller. Logicians are humans, after all, and humans are lazy.\n6 Functional completeness and metalogic # 6.1 Functional completeness vs. completeness of a proof system # As a last point, it is important to keep two notions of completeness apart: Functional completeness of a set of connectives is not the same as completeness of a proof system (that is, for example, a set of axioms plus a set of deduction rules); although both establish a connection between a syntactic and a semantic concept, there are some important differences.\nWhilst functional completeness is about the connection between abbreviations and functions which map to truth values, completeness of a proof system is concerned with the relationship between the set of universally valid formulae and the set of formulae which result from rule-governed sign manipulation.\nProperty of \u0026hellip; syntactic concept semantic concept a set of connectives abbreviations (definitions) truth-functions the set of universally valid formulae deduction validity To get a better idea of how these concepts deviate, consider a language with the same syntax as classical propositional logic and an axiom system of propositional logic, but with the following semantics, which is admittedly not all too inventive:\nWith (Triv) we state that any formula is true. As a direct corollary, then, any formula is universally valid as well, so also every formula whose main connective is one of , , or is. But since we constructed our system to have a classical set of deducible formulae, some valid formulae are not provable. In other words: Our proof system ist not complete with respect to the semantics we stated.\nNonetheless, any set of connectives is functionally complete in our system: No matter what formula we look at, be it of the form , or any other form, it is true. So any abbreviation of one connective by the other results in the same truth-values \u0026ndash; or, as in this case, in the same truth-value.\nNote that if we had chosen a proof system in which any formula is deducible, our proof system would be complete with respect to the given semantics. The functional completeness of our system would not have changed, though. This is the biggest difference between functional completeness and completeness of a proof system: While the former is dependent on a system of deduction, the latter is not.\nWas this article of any help to you? If so, consider leaving a comment or supporting me by buying me a coffee!\nLiterature # Yaqub, A. M. (2015). An Introduction to Metalogic. Broadview Press. To be exact, there are three logical symbols in predicate logic. Next to the quantifiers, there also is the identity sign . Since, as will become clear, functional completeness is about connectives, and the identity sign is a predicate symbol, it is not relevant to what we are up to. Nonetheless, it is interesting to note that identity cannot be defined in classical first-order logic, but has to be added as a primitive symbol. In mereology, set theory and second-order logic, identity can be defined, though.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn intuitionistic logic, the quantifiers are not interdefinable. This is a direct consequence of the fact that intuitionists do not accept DN.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA nerdy side note: Proof by induction on the complexity of formulae or length of proofs can be reduced to the principle of mathematical induction, which itself is a theorem of set theory. A very accessible introduction to the PMI can be found in Yaqub, 2015, pp. 90â€“94.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"08 Apr. 2022","lastmod":"08 Apr. 2022","permalink":"https://Perangelot.github.io/posts/functional-completeness-vom-08.04.2022/","tags":["logic","syntax"],"title":"Functional Completeness"},{"categories":null,"contents":" Table of Contents 1 The Problem with emacs on Windows 2 The Solution to the Problem 2.1 Installing msys2 2.2 Configuring msys2 3 Preparing to Install Emacs 4 Building Emacs 4.1 Configuring the Installation 4.2 Building Emacs 4.3 Setting the Paths 5 Setting up an Emacs Daemon 6 The Next Part of your Journey 1 The Problem with emacs on Windows # TECMACS \u0026ndash; the software emacs originates from \u0026ndash; was written in 1976. Given that it has been developed ever since, it is no wonder it is available for all major operating systems. Nonetheless, some important functions depend on packages which are not natively available on Windows, so by default, an emacs installation on Windows falls short of these.\nThis should be one more reason [Link] for you to consider changing to an open-source operating system such as Linux. Please do not just gloss over this point. Next to security reasons, user-configurability and extendability, there are compelling arguments \u0026ndash; both political and ethical \u0026ndash; why you should not support big-tech companies. Plus there is Tux, the mascot of Linux. And who does not want a penguin as their mascot?\nThat being said, some people depend on Windows if they like it or not (although many people only think this is the case, especially in academia [Link]), and if they want to use an open-source text editor instead of Word, this is a big plus already. So, let\u0026rsquo;s start building emacs from source!\n2 The Solution to the Problem # Since Windows is not capable of providing a satisfactory emacs experience but Linux is, we simply import all the necessary linux libraries to Windows. There are many ways to achieve this, but the one I prefer is to use msys2. msys2 is an open-source software based on cygwin which does exactly what we need: Provide the necessary tools to build Linux software natively on Windows. So installing this piece of software is the first thing we are going to do.\n2.1 Installing msys2 # Visit the website of msys2 and download the latest Windows installer. Double-click it and follow the steps of the installation wizard. I installed it to C:\\msys64.\n2.2 Configuring msys2 # Go to C:\\msys64\\home\\\u0026lt;user\u0026gt; and open .bash.rc with notepad by double-clicking on the file and, if necessary, selecting the notepad among the list of programs. Then, add the following code to the end of the file:\nif [ (uname -o) == \u0026#39;Msys\u0026#39; ]; then export PATH=`echo {PATH} | awk -v RS=: -v ORS=: \u0026#39;/c\\// {next} {print}\u0026#39; | sed \u0026#39;s/:*//\u0026#39;` fi This code snippet makes sure that issuing a command in msys2 which happens to have the same name as a Windows command won\u0026rsquo;t cause problems. Lastly, we want to make sure that msys2 is recognized by Windows. We do that by setting a so-called PATH variable. With that, we just tell Windows to look for executables in that path. This way, we make sure that Windows finds msys2.\nTo do that, open the application launcher by pressing the Windows key, type in \u0026ldquo;environment variables\u0026rdquo; and click on the first result. If you have administrator rights, you can now click on \u0026ldquo;New\u0026rdquo; and add both the path to msys2 and its subfolder /bin. For me, this was C:\\msys64\\mingw64 and C:\\msys64\\mingw64\\bin. If you do not have admin rights, you can just add the paths to your current path(s) by separating them by semicolons as in C:\\msys64\\mingw64\\bin;C:\\msys64\\mingw64\\bin.\nAnd with that, msys2 is configured! You can now go back to C:\\msys64 and open mingw64.exe.\nWarning: Do not open any other of the .exe files. Following the below steps with the wrong executable opened will cause problems.\n3 Preparing to Install Emacs # Now we have the means to get all the software we need to build emacs, but we have not yet downloaded a single file. Thus, the next step is to do clone the packages we need. Conveniently, msys2 also uses pacman, the package manager which by default ships with Arch Linux, so it might even be familiar to you.\nFirst of all, we want to make sure that our package manager is up-to-date:\npacman -Syu The flags S, y and u stand for \u0026ldquo;Sync\u0026rdquo;, \u0026ldquo;refresh\u0026rdquo; and \u0026ldquo;sysupdate\u0026rdquo;, respectively. That being done, we install all tools we need to build emacs from source, starting with the most important ones:\npacman -Sy\\ --needed \\ filesystem \\ msys2-runtime \\ bash \\ libreadline \\ libiconv \\ libarchive \\ libgpgme \\ libcurl \\ pacman \\ ncurses \\ libintl Now we\u0026rsquo;ll need to update pacman again:\npacman -Su Finally, we will download and install the necessary libraries. Depending on your download speed and hardware, this will take quite a while. Perfect time to rethink whether you really need Windows. Remember you can also have two systems installed on your machine [Link] to try out Linux!\npacman -Su \\ autoconf \\ autogen \\ automake \\ automake-wrapper \\ diffutils \\ git \\ guile \\ libgc \\ libguile \\ libidn-devel \\ libltdl \\ libnettle-devel \\ libopenssl \\ libp11-kit-devel \\ libtasn1-devel \\ libunistring \\ make \\ mingw-w64-x86_64-binutils \\ mingw-w64-x86_64-bzip2 \\ mingw-w64-x86_64-cairo \\ mingw-w64-x86_64-crt-git \\ mingw-w64-x86_64-dbus \\ mingw-w64-x86_64-expat \\ mingw-w64-x86_64-fontconfig \\ mingw-w64-x86_64-freetype \\ mingw-w64-x86_64-gcc \\ mingw-w64-x86_64-gcc-libs \\ mingw-w64-x86_64-gdk-pixbuf2 \\ mingw-w64-x86_64-gettext \\ mingw-w64-x86_64-giflib \\ mingw-w64-x86_64-glib2 \\ mingw-w64-x86_64-gmp \\ mingw-w64-x86_64-gnutls \\ mingw-w64-x86_64-harfbuzz \\ mingw-w64-x86_64-headers-git \\ mingw-w64-x86_64-imagemagick \\ mingw-w64-x86_64-isl \\ mingw-w64-x86_64-jansson \\ mingw-w64-x86_64-libffi \\ mingw-w64-x86_64-libgccjit \\ mingw-w64-x86_64-libiconv \\ mingw-w64-x86_64-libidn2 \\ mingw-w64-x86_64-libjpeg-turbo \\ mingw-w64-x86_64-libpng \\ mingw-w64-x86_64-librsvg \\ mingw-w64-x86_64-libsystre \\ mingw-w64-x86_64-libtasn1 \\ mingw-w64-x86_64-libtiff \\ mingw-w64-x86_64-libunistring \\ mingw-w64-x86_64-libwinpthread-git \\ mingw-w64-x86_64-libxml2 \\ mingw-w64-x86_64-mpc \\ mingw-w64-x86_64-mpfr \\ mingw-w64-x86_64-nettle \\ mingw-w64-x86_64-p11-kit \\ mingw-w64-x86_64-pango \\ mingw-w64-x86_64-pixman \\ mingw-w64-x86_64-poppler \\ mingw-w64-x86_64-winpthreads \\ mingw-w64-x86_64-xpm-nox \\ mingw-w64-x86_64-xz \\ mingw-w64-x86_64-zlib \\ mingw-w64-x86_64-jbigkit \\ nano \\ openssl \\ pkgconf \\ tar \\ texinfo \\ wget Having done this, we could in principle compile emacs from source. What we should not forget, though, is that emacs lives from packages \u0026ndash; and they also have dependencies which we need to install. Of course, the code below might not suffice to cover all dependencies your packages need, but it takes care of the most important ones: hunspell to make spell-checking work and poppler to allow pdf-tools to open .pdf files. sqlite already is installed with the binaries above, so org-roam (and also org-roam-ui) will work.\npacman -S mingw-w64-x86_64-hunspell \\ mingw-w64-x86_64-poppler \\ mingw-w64-x86_64-poppler-data Note that whilst only an english dictionary is available via msys2, you can add dictionaries of any language you like by putting them in C:\\msys64\\mingw64\\share\\hunspell. For a list of dictionaries to download, visit this page. Of course, you will need to adjust the emacs code, too, then. But this is a topic for [Link] another post.\nFor those who want to use emacs as a LaTeX editor or like having their formulas overlayed with org-preview, you should also install the texlive binaries. This installation should happen without the help of msys2; if you already have a LaTeX distribution installed, emacs will recognize it once it is configured. If not, you will need to install it. The easiest way I have found is to install TeXlive using an .iso image. There is also MiKTeX, but it ships with a minimal install of packages which, depending on your needs, might not suffice. You can install packages manually, though.\nIf you think of using mu4e as your emacs client on Windows, this might be a problem because there is no msys2 package for mu. You might try your luck with an unofficial package, though.\n4 Building Emacs # Now we have done everything we need to start with the actual building process, so we are going to download the emacs source code from an official github repository:\ngit clone http://git.savannah.gnu.org/r/emacs.git 4.1 Configuring the Installation # Next up, we need to tell emacs what (not) to build. I have chosen to go with every sensible dependency to cover all needs:\nIf you get an error message, you are likely in the wrong folder. Make sure the folder contains autogen.sh. You can do that by running ls, which lists the contents of the folder the console currently operates in.\n4.2 Building Emacs # Now, we\u0026rsquo;re finally ready to do the last step: Actually installing emacs! This will take at least 10 minutes, possibly up to 30. Just run the following code:\nmake make install 4.3 Setting the Paths # With this, you have built your own emacs from source \u0026ndash; Congratulations! To run emacs, we still need to put two files in the binary folder: libdbus-1-3.dll and libgmp-10.dll. You can download them here and here, respectively. Just open the Windows explorer, type %APPDATA% in the folder bar and press Enter. You will now be in C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming. Open the folder called bin and put the .dll file in there. If you now double-click on runemacs.exe, emacs should open.\n5 Setting up an Emacs Daemon # Since emacs is not a Windows program, its performance on Windows is, to put it mildly, not out of this world. Especially if you have a large configuration file, it might take half a minute or even longer to get it started. This, of course, completely interferes with your workflow, so we\u0026rsquo;ll need to find a way to deal with that. And the way to go is as simple as silently starting emacs at startup and letting it pop up whenever we want to edit a file in it. This running-in-the-background service is called a server or a daemon.\nOn Linux, setting up a daemon is as simple as typing in a single command. On Windows, on the other hand, things aren\u0026rsquo;t as easy (as is often the case). To alleviate at least some of the despair, I have written some code which takes care of it and converted it to .exe files. Just download all the .exe files and put them in the folder in which the other emacs executables are. For me, it was C:\\Users\\Vitus\\AppData\\Roaming\\bin. Since this folder by default is in the Path variable, we can skip the first step of the instructions on the github page and only need to follow the other 8 steps described on github; this will approximately take 5 minutes. And that\u0026rsquo;s it. Now you have successfully installed the emacs daemon \u0026ndash; Congratulations!\n6 The Next Part of your Journey # If you have followed this guide up until now, your emacs is ready to use, but it will look unfamiliar and the keybindings will be very different from Windows, so you are likely to be completely overwhelmed. This is normal, and I was, too. For this, reason, as a next step, you will need to set up a configuration file which will make your life easier. If you now feel even more overwhelmed, no worries, this [Link] post is for you. Should you already know how setting up such a file works and just want the familiar keybindings, you might want to check out [Link] this post.\nFor those die-hards who already know all this, just put your configuration file in the folder which in turn contains bin. For me, that was C:\\Users\\Vitus\\AppData\\Roaming. Note that, especially if you use the famous package-manager use-package, you might need to start it more than once to get every package installed.\n","date":"01 Mar. 2022","lastmod":"22 Feb. 2022","permalink":"https://Perangelot.github.io/posts/a-comprehensive-guide-to-installing-emacs-on-windows-vom-09.04.2022/","tags":["emacs","open-source","guide"],"title":"A Comprehensive Guide to Installing emacs on Windows (with daemon!)"}]