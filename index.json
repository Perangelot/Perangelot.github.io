[{"categories":null,"contents":"1 The interdefinability of connectives #  Let us first of all get familiar with one very simple idea: Some logical constants can be defined in terms of others. For example, you can define the material conditional in logic like this:\n  In our example, we used two other connectives, \u0026ldquo;\u0026rdquo; and \u0026ldquo;\u0026rdquo;, to define \u0026ldquo;\u0026rdquo;. We can check that this definition is appriopriate by proving that the definiens yields the same truth-values of the ones usually attributed to the definiendum, for example by means of a truth-table:\n As we can see, the truth conditions for are the same as those for . We can do the same for and :\n    If we wanted to, we could also define the strong alternation like this:\n  As it happens, we have now used two connectives \u0026ndash; \u0026ldquo;\u0026rdquo; and \u0026ldquo;\u0026rdquo; \u0026ndash; to show that all other connectives can be introduced as abbreviations of them. This is not self-evident, since some pairs of connectives are not capable of defining all others, for example \u0026ldquo;\u0026rdquo; \u0026ldquo;\u0026rdquo; or \u0026ldquo;\u0026rdquo; and \u0026ldquo;\u0026rdquo;.\n2 The interdefinability of quantifiers #  So far, we have only looked at connectives, and while this suffices for propositional logic, there are two other logical symbols in predicate logic we need to take into consideration: \u0026ldquo;\u0026rdquo; and \u0026ldquo;\u0026rdquo;. Here, we can also define one quantifier in terms of the other using . For example, we can stipulate that\n  and thereby define the existential quantifier by means of \u0026ldquo;\u0026rdquo; and \u0026ldquo;\u0026rdquo;. To see this is working as intended, we simply need our definition and the rule of Double Negation1:\nOne could, of course, also take \u0026ldquo;\u0026rdquo; as primitive and define \u0026ldquo;\u0026rdquo; in terms of it. Similarly, you can define a weak modal operator like \u0026ldquo;\u0026rdquo; by the corresponding strong one \u0026ndash; \u0026ldquo;\u0026rdquo; in this case \u0026ndash; or vice versa.\n3 A definition of functional completeness #  In the last two sections, we showed that we only need some connectives and quantifiers in our syntax to express all of them. We also understood that not any of logical constants is capable of doing this, so we are talking about an interesting property here \u0026ndash; a property usually called functional completeness or expressive completeness. There are several definitions of this concept, but they only deviate in minor points. I suggest the following definition based on Yaqub, 2015, p. 110:\n 1   With the notion of functional completeness in place, we are now able to express what we discovered in sections 1 and 2 very briefly:\n    4 Functional completeness and metalogic #  It is important to understand that functional completeness of a set of connectives is different from completeness of a proof system (that is, for example, a set of axioms plus a set of deduction rules). Although both establish a connection between a syntactic and a semantic concept, there are some important differences. Whilst functional completeness is about the connection between abbreviations and functions which map to truth values, completeness of a proof system is concerned with the relationship between the set of universally valid formulas and the set of formulas which result from rule-governed sign manipulation.\n   Property of \u0026hellip; syntactic concept semantic concept     a set of connectives abbreviations (definitions) truth-functions   the set of universally valid formulas deduction validity    To get a better idea of how these concepts deviate, consider a language with the same syntax as classical propositional logic and an axiom system of propositional logic, but with the following semantics, which is admittedly not all too inventive:\n\n  With (Triv) we state that any formula is true. As a direct corollary, then, any formula is universally valid as well. But since we have classical deduction rules, not every formula is deducible, so it is not the case that any universally valid formula is also deducible. In other words: Our proof system ist not complete with respect to the semantics we stated.\nNonetheless, any set of connectives is functionally complete: No matter what formula we look at, be it of the form , or any other form, it is true. So any abbreviation of one connective by the other results in the same truth-values \u0026ndash; or, as in this case, the same truth-value.\nNote that if we had chosen as proof system in which any formula is deducible, our proof system would be complete with respect to the given semantics. It is the dependency of the proof system that is the biggest difference between functional completeness and completeness of a proof system.\nAny definition is stated with help of syntax, as a notational convention of abbreviation; but to say that an expression is syntactically definable is to say something more, namely that it is explicable as an abbreviation of an expression which is itself composed of just the notations of syntax. quine, 286, math logic\nReferences #  .csl-entry{text-indent: -1.5em; margin-left: 1.5em;}Yaqub, A. M. (2015). An Introduction to Metalogic. Broadview Press.    In intuitionistic logic, the quantifiers are not interdefinable. This is a direct consequence of the fact that intuitionists do not accept DN.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"08 Apr. 2022","lastmod":"08 Apr. 2022","permalink":"https://Perangelot.github.io/posts/functional-completeness-vom-08.04.2022/","tags":["logic","syntax"],"title":"Functional Completeness"},{"categories":null,"contents":" .ox-hugo-toc ul { list-style: none; }  Table of Contents  1 The Problem with emacs on Windows 2 The Solution to the Problem  2.1 Installing msys2 2.2 Configuring msys2   3 Preparing to Install Emacs 4 Building Emacs  4.1 Configuring the Installation 4.2 Building Emacs 4.3 Setting the Paths   5 Setting up an Emacs Daemon 6 The Next Part of your Journey    1 The Problem with emacs on Windows #  TECMACS \u0026ndash; the software emacs originates from \u0026ndash; was written in 1976. Given that it has been developed ever since, it is no wonder it is available for all major operating systems. Nonetheless, some important functions depend on packages which are not natively available on Windows, so by default, an emacs installation on Windows falls short of these.\nThis should be one more reason [Link] for you to consider changing to an open-source operating system such as Linux. Please do not just gloss over this point. Next to security reasons, user-configurability and extendability, there are compelling arguments \u0026ndash; both political and ethical \u0026ndash; why you should not support big-tech companies. Plus there is Tux, the mascot of Linux. And who does not want a penguin as their mascot?\nThat being said, some people depend on Windows if they like it or not (although many people only think this is the case, especially in academia [Link]), and if they want to use an open-source text editor instead of Word, this is a big plus already. So, let\u0026rsquo;s start building emacs from source!\n2 The Solution to the Problem #  Since Windows is not capable of providing a satisfactory emacs experience but Linux is, we simply import all the necessary linux libraries to Windows. There are many ways to achieve this, but the one I prefer is to use msys2. msys2 is an open-source software based on cygwin which does exactly what we need: Provide the necessary tools to build Linux software natively on Windows. So installing this piece of software is the first thing we are going to do.\n2.1 Installing msys2 #  Visit the website of msys2 and download the latest Windows installer. Double-click it and follow the steps of the installation wizard. I installed it to C:\\msys64.\n2.2 Configuring msys2 #  Go to C:\\msys64\\home\\\u0026lt;user\u0026gt; and open .bash.rc with notepad by double-clicking on the file and, if necessary, selecting the notepad among the list of programs. Then, add the following code to the end of the file:\nif [ (uname -o) == \u0026#39;Msys\u0026#39; ]; then \texport PATH=`echo {PATH} | awk -v RS=: -v ORS=: \u0026#39;/c\\// {next} {print}\u0026#39; | sed \u0026#39;s/:*//\u0026#39;` fi This code snippet makes sure that issuing a command in msys2 which happens to have the same name as a Windows command won\u0026rsquo;t cause problems. Lastly, we want to make sure that msys2 is recognized by Windows. We do that by setting a so-called PATH variable. With that, we just tell Windows to look for executables in that path. This way, we make sure that Windows finds msys2.\nTo do that, open the application launcher by pressing the Windows key, type in \u0026ldquo;environment variables\u0026rdquo; and click on the first result. If you have administrator rights, you can now click on \u0026ldquo;New\u0026rdquo; and add both the path to msys2 and its subfolder /bin. For me, this was C:\\msys64\\mingw64 and C:\\msys64\\mingw64\\bin. If you do not have admin rights, you can just add the paths to your current path(s) by separating them by semicolons as in C:\\msys64\\mingw64\\bin;C:\\msys64\\mingw64\\bin.\nAnd with that, msys2 is configured! You can now go back to C:\\msys64 and open mingw64.exe.\nWarning: Do not open any other of the .exe files. Following the below steps with the wrong executable opened will cause problems.\n3 Preparing to Install Emacs #  Now we have the means to get all the software we need to build emacs, but we have not yet downloaded a single file. Thus, the next step is to do clone the packages we need. Conveniently, msys2 also uses pacman, the package manager which by default ships with Arch Linux, so it might even be familiar to you.\nFirst of all, we want to make sure that our package manager is up-to-date:\npacman -Syu The flags S, y and u stand for \u0026ldquo;Sync\u0026rdquo;, \u0026ldquo;refresh\u0026rdquo; and \u0026ldquo;sysupdate\u0026rdquo;, respectively. That being done, we install all tools we need to build emacs from source, starting with the most important ones:\npacman -Sy\\ \t--needed \\ \tfilesystem \\ \tmsys2-runtime \\ \tbash \\ \tlibreadline \\ \tlibiconv \\ \tlibarchive \\ \tlibgpgme \\ \tlibcurl \\ \tpacman \\ \tncurses \\ \tlibintl Now we\u0026rsquo;ll need to update pacman again:\npacman -Su Finally, we will download and install the necessary libraries. Depending on your download speed and hardware, this will take quite a while. Perfect time to rethink whether you really need Windows. Remember you can also have two systems installed on your machine [Link] to try out Linux!\npacman -Su \\ \tautoconf \\ \tautogen \\ \tautomake \\ \tautomake-wrapper \\ \tdiffutils \\ \tgit \\ \tguile \\ \tlibgc \\ \tlibguile \\ \tlibidn-devel \\ \tlibltdl \\ \tlibnettle-devel \\ \tlibopenssl \\ \tlibp11-kit-devel \\ \tlibtasn1-devel \\ \tlibunistring \\ \tmake \\ \tmingw-w64-x86_64-binutils \\ \tmingw-w64-x86_64-bzip2 \\ \tmingw-w64-x86_64-cairo \\ \tmingw-w64-x86_64-crt-git \\ \tmingw-w64-x86_64-dbus \\ \tmingw-w64-x86_64-expat \\ \tmingw-w64-x86_64-fontconfig \\ \tmingw-w64-x86_64-freetype \\ \tmingw-w64-x86_64-gcc \\ \tmingw-w64-x86_64-gcc-libs \\ \tmingw-w64-x86_64-gdk-pixbuf2 \\ \tmingw-w64-x86_64-gettext \\ \tmingw-w64-x86_64-giflib \\ \tmingw-w64-x86_64-glib2 \\ \tmingw-w64-x86_64-gmp \\ \tmingw-w64-x86_64-gnutls \\ \tmingw-w64-x86_64-harfbuzz \\ \tmingw-w64-x86_64-headers-git \\ \tmingw-w64-x86_64-imagemagick \\ \tmingw-w64-x86_64-isl \\ \tmingw-w64-x86_64-jansson \\ \tmingw-w64-x86_64-libffi \\ \tmingw-w64-x86_64-libgccjit \\ \tmingw-w64-x86_64-libiconv \\ \tmingw-w64-x86_64-libidn2 \\ \tmingw-w64-x86_64-libjpeg-turbo \\ \tmingw-w64-x86_64-libpng \\ \tmingw-w64-x86_64-librsvg \\ \tmingw-w64-x86_64-libsystre \\ \tmingw-w64-x86_64-libtasn1 \\ \tmingw-w64-x86_64-libtiff \\ \tmingw-w64-x86_64-libunistring \\ \tmingw-w64-x86_64-libwinpthread-git \\ \tmingw-w64-x86_64-libxml2 \\ \tmingw-w64-x86_64-mpc \\ \tmingw-w64-x86_64-mpfr \\ \tmingw-w64-x86_64-nettle \\ \tmingw-w64-x86_64-p11-kit \\ \tmingw-w64-x86_64-pango \\ \tmingw-w64-x86_64-pixman \\ \tmingw-w64-x86_64-poppler \\ \tmingw-w64-x86_64-winpthreads \\ \tmingw-w64-x86_64-xpm-nox \\ \tmingw-w64-x86_64-xz \\ \tmingw-w64-x86_64-zlib \\ \tmingw-w64-x86_64-jbigkit \\ \tnano \\ \topenssl \\ \tpkgconf \\ \ttar \\ \ttexinfo \\ \twget Having done this, we could in principle compile emacs from source. What we should not forget, though, is that emacs lives from packages \u0026ndash; and they also have dependencies which we need to install. Of course, the code below might not suffice to cover all dependencies your packages need, but it takes care of the most important ones: hunspell to make spell-checking work and poppler to allow pdf-tools to open .pdf files. sqlite already is installed with the binaries above, so org-roam (and also org-roam-ui) will work.\npacman -S mingw-w64-x86_64-hunspell \\ \tmingw-w64-x86_64-poppler \\ \tmingw-w64-x86_64-poppler-data Note that whilst only an english dictionary is available via msys2, you can add dictionaries of any language you like by putting them in C:\\msys64\\mingw64\\share\\hunspell. For a list of dictionaries to download, visit this page. Of course, you will need to adjust the emacs code, too, then. But this is a topic for [Link] another post.\nFor those who want to use emacs as a LaTeX editor or like having their formulas overlayed with org-preview, you should also install the texlive binaries. This installation should happen without the help of msys2; if you already have a LaTeX distribution installed, emacs will recognize it once it is configured. If not, you will need to install it. The easiest way I have found is to install TeXlive using an .iso image. There is also MiKTeX, but it ships with a minimal install of packages which, depending on your needs, might not suffice. You can install packages manually, though.\nIf you think of using mu4e as your emacs client on Windows, this might be a problem because there is no msys2 package for mu. You might try your luck with an unofficial package, though.\n4 Building Emacs #  Now we have done everything we need to start with the actual building process, so we are going to download the emacs source code from an official github repository:\ngit clone http://git.savannah.gnu.org/r/emacs.git 4.1 Configuring the Installation #  Next up, we need to tell emacs what (not) to build. I have chosen to go with every sensible dependency to cover all needs:\nIf you get an error message, you are likely in the wrong folder. Make sure the folder contains autogen.sh. You can do that by running ls, which lists the contents of the folder the console currently operates in.\n4.2 Building Emacs #  Now, we\u0026rsquo;re finally ready to do the last step: Actually installing emacs! This will take at least 10 minutes, possibly up to 30. Just run the following code:\nmake make install 4.3 Setting the Paths #  With this, you have built your own emacs from source \u0026ndash; Congratulations! To run emacs, we still need to put two files in the binary folder: libdbus-1-3.dll and libgmp-10.dll. You can download them here and here, respectively. Just open the Windows explorer, type %APPDATA% in the folder bar and press Enter. You will now be in C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming. Open the folder called bin and put the .dll file in there. If you now double-click on runemacs.exe, emacs should open.\n5 Setting up an Emacs Daemon #  Since emacs is not a Windows program, its performance on Windows is, to put it mildly, not out of this world. Especially if you have a large configuration file, it might take half a minute or even longer to get it started. This, of course, completely interferes with your workflow, so we\u0026rsquo;ll need to find a way to deal with that. And the way to go is as simple as silently starting emacs at startup and letting it pop up whenever we want to edit a file in it. This running-in-the-background service is called a server or a daemon.\nOn Linux, setting up a daemon is as simple as typing in a single command. On Windows, on the other hand, things aren\u0026rsquo;t as easy (as is often the case). To alleviate at least some of the despair, I have written some code which takes care of it and converted it to .exe files. Just download all the .exe files and put them in the folder in which the other emacs executables are. For me, it was C:\\Users\\Vitus\\AppData\\Roaming\\bin. Since this folder by default is in the Path variable, we can skip the first step of the instructions on the github page and only need to follow the other 8 steps described on github; this will approximately take 5 minutes. And that\u0026rsquo;s it. Now you have successfully installed the emacs daemon \u0026ndash; Congratulations!\n6 The Next Part of your Journey #  If you have followed this guide up until now, your emacs is ready to use, but it will look unfamiliar and the keybindings will be very different from Windows, so you are likely to be completely overwhelmed. This is normal, and I was, too. For this, reason, as a next step, you will need to set up a configuration file which will make your life easier. If you now feel even more overwhelmed, no worries, this [Link] post is for you. Should you already know how setting up such a file works and just want the familiar keybindings, you might want to check out [Link] this post.\nFor those die-hards who already know all this, just put your configuration file in the folder which in turn contains bin. For me, that was C:\\Users\\Vitus\\AppData\\Roaming. Note that, especially if you use the famous package-manager use-package, you might need to start it more than once to get every package installed.\n","date":"01 Mar. 2022","lastmod":"22 Feb. 2022","permalink":"https://Perangelot.github.io/posts/a-comprehensive-guide-to-installing-emacs-on-windows-vom-09.04.2022/","tags":["emacs","open-source","guide"],"title":"A Comprehensive Guide to Installing emacs on Windows (with daemon!)"}]